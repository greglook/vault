(ns vault.data
  "Code to handle structured data, usually represented as EDN."
  (:require
    [clojure.string :as string]
    [fipp.printer :refer [pprint-document]]
    [puget.printer :as puget]))


(def ^:private ^:const blob-width
  "Width of text to use in serialized blobs."
  100)


(defn edn-blob
  "Returns a canonical EDN representation suitable for serializing to a blob."
  [value]
  (let [doc (binding [puget/*colored-output* false
                      puget/*strict-mode* true]
              (puget/canonize value))
        doc (if (puget/tagged-value-doc? doc)
              (let [[op tag sep & more] doc]
                `[~op ~tag :line ~@more])
              doc)]
    (-> doc
        (pprint-document {:width blob-width})
        with-out-str
        string/trim)))



; I think I'm going to have to use assumption or a-priori knowledge to know if
; a given byte sequence is EDN data or not. Either the program is following a
; reference which *should* be EDN, or there's a content-type returned which
; specifies "application/edn", etc.
;
; This doesn't solve the problem of scanning the blob store or say, an indexer
; receiving a new blob which needs to figure out "what it is". From experiments
; trying to read randomly-generated byte sequences as EDN, if the reader either
; throws an exception or returns a symbol, it's not an EDN blob.


; TODO: write middle-layer pushback reader proxy to capture substring info for
; indexed signatures. Then reread blob to pick out the necessary bytes?
; When reading signatures, need to resolve the 'target' - either a full blob
; or the initial bytes
