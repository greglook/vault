; Large binary data is represented by a tree structure in order to share
; subsegments of the byte sequence. This lets a section of the data change
; without having to re-store the unchanged sections
;
; A byte sequence is a vector of _parts_, each of which may be a reference to
; a nested bytes structure, a reference to a blob of byte data, or a sequence of
; zero-valued bytes.
;
; Each part in the vector must be a map containing a :size key. The value of
; this key specifies the number of bytes in the sequence contributed by the
; part. The part size must be a positive integer.
;
; If no other keys are present, the part represents an all-zero region of bytes,
; such as in a sparse file. Otherwise, the part must contain a :bytes or :parts
; key. It is an error for a part to contain both. A :bytes key specifies a
; reference to a blob whose content should be used directly as byte data. A
; :parts key refers to another bytes structure with further sub-parts.
;
; For either :bytes or :parts sources, the :size key gives the number of bytes
; to take from the source. If the part size is smaller than the size of the
; source, extra bytes are omitted. The part size SHOULD NOT be larger than the
; source, but if so the part is padded with trailing zero bytes.
;
; Parts may also give an :offset key specifying the number of bytes to skip
; at the start of the source; this defaults to zero if unspecified. The part
; offset must be a non-negative integer.
;
; The size of a byte sequence can be trivially calculated by summing the sizes
; of the parts.


; Example (mostly empty) ~1.5 MB sequence:

#vault/data
^{:type :vault/byte-seq}
[{:size 1000000}
 {:bytes #vault/ref "algo:digest",
  :size 1024}
 {:offset 492,
  :parts #vault/ref "algo:digest",
  :size 500000}]
